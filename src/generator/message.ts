import {
  SOL_PRAGMA,
  SPDX_LICENSE,
  protoNameToSol,
  codecLibName
} from "../util/names.js"
import { log } from "../util/logger.js"
import {
  FieldInfo,
  genStructMember,
  genFieldEncode,
  genFieldDecode
} from "./field.js"
import { PROTO_TYPE_MAP, WireType } from "./type-map.js"

/**
 * Descriptor subset for a protobuf message needed by the codegen.
 */
export interface MessageDescriptor {
  /** Simple name (e.g. "MyMessage") */
  name: string
  /** Fully qualified name (e.g. ".my_package.MyMessage") */
  fullName: string
  /** Field descriptors */
  fields: FieldInfo[]
  /** Nested message descriptors (for map entry types, etc.) */
  nestedMessages: MessageDescriptor[]
  /** True if this message is a synthetic map entry */
  isMapEntry: boolean
}

/**
 * Collected imports needed by a generated .sol file.
 */
interface ImportSet {
  /** Always true — we always import the runtime */
  runtime: boolean
  /** Codec library names for nested message types */
  codecs: Set<string>
}

/**
 * Generate a complete .sol file containing struct definitions and
 * encode/decode codec libraries for all non-map-entry messages
 * in a given proto file.
 */
export function generateSolFile(
  messages: MessageDescriptor[],
  protoFileName: string
): string {
  const lines: string[] = []

  lines.push(`// SPDX-License-Identifier: ${SPDX_LICENSE}`)
  lines.push(`pragma solidity ${SOL_PRAGMA};`)
  lines.push(``)
  lines.push(`// Auto-generated by protoc-gen-solidity from ${protoFileName}`)
  lines.push(`// DO NOT EDIT`)
  lines.push(``)
  lines.push(`import {ProtobufRuntime} from "./ProtobufRuntime.sol";`)
  lines.push(``)

  // Collect codec imports for cross-message references
  const imports = resolveImports(messages)
  // (Cross-file imports would go here; intra-file refs resolve naturally)

  // Generate structs first (forward declarations)
  for (const msg of messages) {
    if (msg.isMapEntry) continue
    lines.push(genStruct(msg))
    lines.push(``)
  }

  // Generate codec libraries
  for (const msg of messages) {
    if (msg.isMapEntry) continue
    lines.push(genCodecLibrary(msg))
    lines.push(``)
  }

  return lines.join("\n")
}

/**
 * Generate Solidity struct definition for a message.
 */
function genStruct(msg: MessageDescriptor): string {
  const name = protoNameToSol(msg.fullName)
  log.debug(`Generating struct ${name} (${msg.fields.length} fields)`)

  const members = msg.fields
    .filter(f => !isMapEntryField(f, msg))
    .map(f => {
      // If this field references a map entry, convert to parallel arrays
      const mapEntry = resolveMapEntry(f, msg)
      if (mapEntry) {
        return genStructMember({ ...f, mapEntry })
      }
      return genStructMember(f)
    })

  return [`struct ${name} {`, ...members, `}`].join("\n")
}

/**
 * Generate the codec library with encode() and decode() for a message.
 */
function genCodecLibrary(msg: MessageDescriptor): string {
  const structName = protoNameToSol(msg.fullName)
  const libName = codecLibName(structName)

  log.debug(`Generating codec library ${libName}`)

  const encodeBody = genEncodeFunction(msg, structName)
  const decodeBody = genDecodeFunction(msg, structName)

  return [
    `library ${libName} {`,
    ``,
    encodeBody,
    ``,
    decodeBody,
    `}`
  ].join("\n")
}

/**
 * Generate the encode function body.
 */
function genEncodeFunction(
  msg: MessageDescriptor,
  structName: string
): string {
  const lines: string[] = []
  lines.push(
    `  function encode(${structName} memory msg) internal pure returns (bytes memory) {`
  )
  lines.push(`    bytes memory buf = "";`)

  for (const field of msg.fields) {
    if (isMapEntryField(field, msg)) continue

    const mapEntry = resolveMapEntry(field, msg)
    const fieldInfo = mapEntry ? { ...field, mapEntry } : field

    lines.push(``)
    lines.push(`    // field ${field.number}: ${field.name}`)
    lines.push(genFieldEncode(fieldInfo))
  }

  lines.push(``)
  lines.push(`    return buf;`)
  lines.push(`  }`)
  return lines.join("\n")
}

/**
 * Generate the decode function body with tag-dispatch loop.
 */
function genDecodeFunction(
  msg: MessageDescriptor,
  structName: string
): string {
  const lines: string[] = []
  lines.push(
    `  function decode(bytes memory data) internal pure returns (${structName} memory msg) {`
  )
  lines.push(`    uint256 pos = 0;`)
  lines.push(`    uint256 end = data.length;`)
  lines.push(``)
  lines.push(`    while (pos < end) {`)
  lines.push(`      uint64 tag;`)
  lines.push(`      (tag, pos) = ProtobufRuntime._decode_key(data, pos);`)
  lines.push(``)
  lines.push(`      // solhint-disable-next-line no-empty-blocks`)
  lines.push(`      switch (tag) {`)

  for (const field of msg.fields) {
    if (isMapEntryField(field, msg)) continue

    const mapEntry = resolveMapEntry(field, msg)
    const fieldInfo = mapEntry ? { ...field, mapEntry } : field

    lines.push(genFieldDecode(fieldInfo))
  }

  lines.push(`        default:`)
  lines.push(
    `          pos = ProtobufRuntime._skip_field(data, pos, tag & 0x07);`
  )
  lines.push(`          break;`)
  lines.push(`      }`)
  lines.push(`    }`)
  lines.push(`  }`)
  return lines.join("\n")
}

// ── Map entry resolution ──────────────────────────────────────────────

interface MapEntryInfo {
  keyType: number
  valueType: number
  valueTypeName?: string
}

/**
 * Check if a field references a map entry message type.
 */
function isMapEntryField(
  field: FieldInfo,
  parentMsg: MessageDescriptor
): boolean {
  if (field.type !== 11 || field.label !== 3) return false
  const nested = parentMsg.nestedMessages.find(
    m => field.typeName?.endsWith(`.${m.name}`)
  )
  return nested?.isMapEntry ?? false
}

/**
 * Resolve a map entry's key/value types from the synthetic nested message.
 */
function resolveMapEntry(
  field: FieldInfo,
  parentMsg: MessageDescriptor
): MapEntryInfo | undefined {
  if (field.type !== 11 || field.label !== 3) return undefined
  const nested = parentMsg.nestedMessages.find(
    m => field.typeName?.endsWith(`.${m.name}`)
  )
  if (!nested?.isMapEntry) return undefined

  const keyField = nested.fields.find(f => f.number === 1)
  const valField = nested.fields.find(f => f.number === 2)
  if (!keyField || !valField) return undefined

  return {
    keyType: keyField.type,
    valueType: valField.type,
    valueTypeName: valField.typeName
  }
}

/**
 * Collect the set of codec imports needed for a list of messages.
 */
function resolveImports(messages: MessageDescriptor[]): ImportSet {
  const codecs = new Set<string>()
  for (const msg of messages) {
    if (msg.isMapEntry) continue
    for (const field of msg.fields) {
      if (field.type === 11 && field.typeName) {
        const nested = msg.nestedMessages.find(
          m => field.typeName?.endsWith(`.${m.name}`)
        )
        if (!nested?.isMapEntry) {
          const solName = protoNameToSol(field.typeName)
          codecs.add(codecLibName(solName))
        }
      }
    }
  }
  return { runtime: true, codecs }
}
